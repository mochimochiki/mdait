# 作業チケット: sync処理のマーカー更新ロジック統一とStatusItem構造リファクタリング

## 1. 概要と方針

syncコマンドのマーカー更新ロジックに重複と不統一が存在する。syncFrontmatterMarkers関数とupdateSectionHashes関数のロジックを統一し、コードの保守性と可読性を向上させる。

また、`FileStatusItem.children`の型設計を見直し、frontmatterを独立プロパティとして扱うことで、型安全性と概念的整合性を向上させる。

## 2. 問題点

### 問題0: FileStatusItem.childrenの型設計が不適切

**場所**: `src/core/status/status-item.ts`

**現状**:
```typescript
// children が UnitStatusItem | FrontmatterStatusItem の共用体型になっている
export type FileChildStatusItem = UnitStatusItem | FrontmatterStatusItem;
export interface FileStatusItem extends BaseStatusItem {
    children?: FileChildStatusItem[];
}
```

**問題**:
1. **多重度の不整合**: Frontmatterはファイルに0か1個、Unitは0個以上。異なる多重度を同じ配列で扱うのは不自然
2. **型ガードの乱用**: childrenを使う多くの箇所でフィルタリングや型ガードが必要
   - `getUnitsFromFile()`: `children.filter(child => child.type === StatusItemType.Unit)`
   - `sync-command.ts`: `isUnitStatusItem(child)`でフィルタ
   - `status-item-tree.ts`: `child.type !== StatusItemType.Unit`チェック
3. **設計の矛盾**: `determineFileStatus`は`frontmatterItem`を別パラメータで受け取っており、内部では別概念として扱っている
4. **拡張性の低下**: 将来別のタイプが追加された場合、さらに複雑化

**推奨設計**:
```typescript
export interface FileStatusItem extends BaseStatusItem {
    children?: UnitStatusItem[];          // Unit専用に戻す
    frontmatter?: FrontmatterStatusItem;  // 独立プロパティとして追加
}
```

### 問題1: updateSectionHashesとsyncFrontmatterMarkersのロジック重複

**場所**: 
- `updateSectionHashes()`: 412-490行目（ユニット用）
- `syncFrontmatterMarkers()`: 343-407行目（frontmatter用）

**問題**:
両関数で以下の処理が重複している：
- マーカーの存在確認
- ハッシュ計算
- 変更検出（isSourceChanged, isTargetChanged）
- need設定ロジック（translate/revise/solve-conflict）

**影響**:
- ロジックの修正時に両方を更新する必要がある
- バグ混入のリスクが高い
- テストの重複

### 問題2: updateSectionHashesのロジックが複雑

**場所**: updateSectionHashes関数（412-490行目）

**問題**:
- 3つのケース（source+target, sourceのみ, targetのみ）を個別に処理
- 各ケースでマーカー更新ロジックが微妙に異なる
- 早期continueが多用され、フロー追跡が困難

**影響**:
- 可読性が低い
- エッジケースでのバグ混入リスク
- 単体テストが困難

### 問題3: needフラグ設定条件の不統一

**updateSectionHashes（ユニット）**:
- 競合: `isSourceChanged && isTargetChanged` → `solve-conflict`
- Source変更: `oldSourceHash !== sourceMarker.hash` → `revise` or `translate`
- Target変更のみ: needフラグ設定なし

**syncFrontmatterMarkers（frontmatter）**:
- 競合: `isSourceChanged && isTargetChanged` → `solve-conflict`
- Source変更: `isSourceChanged && !isTargetChanged` → `revise` or `translate`
- Target変更のみ: needフラグ設定なし
- 初回sync: `!existingMarker && !marker.need` → `translate`

**問題**: 
- ユニットとfrontmatterで微妙に条件が異なる
- 特に初回syncの扱いが不統一

### 問題4: マーカー更新の責務が分散

**場所**:
- `ensureMdaitMarkerHash()`: 基本的なハッシュ付与のみ
- `updateSectionHashes()`: 変更検出とneed設定
- `syncFrontmatterMarkers()`: frontmatter専用の完全処理

**問題**:
- 責務の境界が不明確
- どの関数がどこまで処理するか理解しづらい

## 3. 設計方針

### 3.1 共通マーカー更新ロジックの抽出

```mermaid
graph TD
    A[Marker更新要求] --> B{初回sync?}
    B -->|Yes| C[新規マーカー作成]
    B -->|No| D[既存マーカー取得]
    C --> E[ハッシュ計算]
    D --> E
    E --> F{変更検出}
    F --> G[isSourceChanged判定]
    F --> H[isTargetChanged判定]
    G --> I{need設定判定}
    H --> I
    I --> J[solve-conflict]
    I --> K[revise@oldhash]
    I --> L[translate]
    I --> M[変更なし]
```

### 3.2 新しい設計構造

```typescript
// 共通のマーカー更新ロジック
interface MarkerUpdateContext {
  currentHash: string;
  fromHash: string | null;
  existingMarker: MdaitMarker | null;
}

interface MarkerUpdateResult {
  marker: MdaitMarker;
  changed: boolean;
}

function updateMarker(
  context: MarkerUpdateContext,
  oldHash: string,
  newHash: string
): MarkerUpdateResult {
  // 統一されたマーカー更新ロジック
}
```

### 3.3 統一後の呼び出しフロー

```
syncNew_CoreProc / sync_CoreProc
  ↓
  ユニット処理: ensureMdaitMarkerHash
  ↓
  frontmatter処理: syncFrontmatterMarkers
  ↓
  ユニット同期: updateSectionHashes → 内部でupdateMarkerを呼び出し
```

## 4. 実装計画と進捗

### フェーズ0: StatusItem構造リファクタリング（高優先度・先行実施）✅完了

**目的**: `FileStatusItem.children`を`UnitStatusItem[]`専用に戻し、frontmatterを独立プロパティ化

- [x] `FileStatusItem`に`frontmatter?: FrontmatterStatusItem`プロパティを追加
- [x] `FileStatusItem.children`の型を`UnitStatusItem[]`に変更
- [x] `FileChildStatusItem`型を削除
- [x] `getUnitsFromFile()`ヘルパー関数を簡素化（フィルタ不要に）
- [x] `StatusCollector.collectFileStatus`を修正
  - `children.push(frontmatterItem)` → `frontmatter: frontmatterItem`
- [x] `StatusCollector.determineFileStatus`のシグネチャ簡素化
  - childrenパラメータを`UnitStatusItem[]`に変更
- [x] `StatusItemTree.addOrUpdateFile`を修正
  - 型ガード不要に（childrenは常にUnitStatusItem[]）
  - frontmatterの翻訳中フラグも考慮
- [x] `StatusItemTree.updateUnit`を修正
  - 型ガード不要に
- [x] `sync-command.ts`のGC処理を修正
  - `isUnitStatusItem(child)`チェック削除（不要に）
- [x] テストコードを更新
  - `children?.find(isFrontmatterStatusItem)` → `fileStatus.frontmatter`

### フェーズ1: 共通ロジック抽出（高優先度）✅完了

- [x] MarkerSyncContextとMarkerSyncResultの型定義
- [x] syncSourceMarker共通関数の実装（source側マーカー同期）
- [x] syncTargetMarker共通関数の実装（target側マーカー同期：変更検出、need設定）
- [x] syncMarkerPair共通関数の実装（source-targetペア同期）
- [x] 単体テストの実装（src/test/commands/sync/marker-sync.test.ts）

### フェーズ2: updateSectionHashesのリファクタリング（高優先度）✅完了

- [x] updateSectionHashesをsyncMarkerPair, syncSourceMarkerを使うように書き換え
- [x] 3つのケース（source+target, sourceのみ, targetのみ）を統一
- [x] コード量を約80行から約35行に削減
- [x] 既存テストが通ることを確認

### フェーズ3: syncFrontmatterMarkersのリファクタリング（中優先度）✅完了

- [x] syncFrontmatterMarkersをsyncSourceMarker, syncTargetMarkerを使うように書き換え
- [x] ユニット処理との一貫性を確保
- [x] 既存テストが通ることを確認

### フェーズ4: エッジケース対応（中優先度）✅完了

- [x] frontmatterテストのundefined vs null問題を修正
- [x] source変更時のrevise設定テストを正しく設定（targetHash一致が必要）
- [x] 全248テストがパス


## 5. 考慮事項

### 5.0 フェーズ0（StatusItem構造リファクタリング）の影響範囲

**変更対象ファイル**:
| ファイル | 変更内容 |
|---------|---------|
| `src/core/status/status-item.ts` | `FileStatusItem`に`frontmatter`追加、`children`型変更、`FileChildStatusItem`削除 |
| `src/core/status/status-collector.ts` | `collectFileStatus`, `determineFileStatus`修正 |
| `src/core/status/status-item-tree.ts` | TreeView表示でfrontmatterを考慮 |
| `src/commands/sync/sync-command.ts` | GC処理の型ガード削除 |
| `src/test/core/status/status-collector-frontmatter.test.ts` | frontmatterアクセス方法変更 |
| `src/test-gui/core/status-collector-frontmatter.test.ts` | 同上 |

**リスク軽減策**:
- フェーズ0を独立したコミットとして実施
- 全テスト通過を確認後に次フェーズへ

### 5.1 既存機能への影響

- syncコマンドの中核ロジックの変更のため、既存の全テストが通ることを確認
- E2Eテストでの動作確認も必須
- 段階的なリファクタリングで影響範囲を最小化

### 5.2 テスト戦略

- updateMarker関数の単体テストを最優先で実装
- 各種エッジケースを網羅（初回sync, 競合, revise, 片側のみ変更など）
- 既存のsyncFrontmatterMarkers, updateSectionHashesのテストも維持

### 5.3 互換性

- 既存のマーカー形式は変更しない
- ファイルフォーマットへの影響なし
- APIの変更は内部のみ（public APIは変更しない）

## 6. リスク評価

### 高リスク
- updateSectionHashesの変更が既存のsync動作に影響する可能性
- 競合検出ロジックの変更によるデータ損失リスク

### 中リスク
- パフォーマンスへの影響（リファクタリングによる処理速度の変化）
- テストカバレッジの不足によるバグ混入

### 低リスク
- 新規コードの追加のみ（既存コードは段階的に置き換え）

## 7. 成功基準

- [x] すべてのユニットテストが通る（248テストパス）
- [ ] 既存のE2Eテストが通る
- [x] コードの重複行数が50%以上削減（updateSectionHashes: 80行→35行）
- [x] updateSectionHashesの複雑度が50%以上削減
- [x] 新規追加されたテストカバレッジが80%以上（marker-sync.tsの14テスト）

## 8. 完了後のメリット

1. **型安全性向上**: `children`が`UnitStatusItem[]`専用になり、型ガード不要
2. **概念的整合性**: Frontmatter（0か1個）とUnit（0個以上）の多重度を正確に表現
3. **保守性向上**: マーカー更新ロジックが1箇所に集約され、修正が容易
4. **可読性向上**: 処理フローが明確になり、理解しやすい
5. **バグ削減**: ロジックの重複がなくなり、バグ混入リスクが低下
6. **テスト容易性**: 共通関数の単体テストで広範囲をカバー可能
7. **拡張性**: 新しいマーカータイプの追加が容易
