# 修正指示（プロトタイプ前提・破壊的変更OK）

## 前提（重要）

* 本実装は **プロトタイプ段階**であり、後方互換性・既存データの移行は **一切考慮しない**
* 既存の `need:solve-conflict` マーカーや挙動は **破壊的に削除**してよい
* 動かなくなる既存ファイルがあっても問題なし
  → 新仕様で再 sync / 再生成されることを前提とする

---

## 基本方針（最優先）

* `need:solve-conflict` という概念を **コードから完全に削除**
* **source / target の両方が変更されても「競合」とは扱わない**
* すべて **`need:revise` 系の通常改訂フローに統一**
* marker の `from` / `hash` は **常に最新の観測値に更新**する
  （未解決状態を理由にハッシュ更新を止める設計は禁止）

> 未解決状態は「need タグ」で表す
> ハッシュは「現在の実体を表す観測値」として必ず更新する

---

## 状態モデル（簡略化）

### 廃止する状態

* `need:solve-conflict`
* conflict 判定

### 採用する状態

* `need:revise`
* source が変わったら revise
* **source + target 両方変わっても revise**

---

## marker-sync.ts への具体指示

### 1) conflict 判定ロジックを全削除

以下を含む一切の処理を削除：

* `isSourceChanged && isTargetChanged` による conflict 分岐
* `setNeed("solve-conflict")`
* `changeType: "conflict"`
* conflict を理由に marker 更新をスキップする処理

---

### 2) 両方変更時の新ルール

**source が変更されていたら**：
1. 原文のハッシュ更新
2. ターゲット側に `need:revise` を付与
3. ターゲット側のハッシュ更新

* target が変更されていても、それは conflict 判定には使わない

**シナリオ**:
原文に修正点があり、訳文側で何か冠詞などに修正を加えたとする。
→原文ハッシュ更新・訳文need:revise・訳文側ハッシュも更新。翻訳時は原文の差分が翻訳LLMに伝えられるので適切に改訂が可能
→仮にそこで競合するような変更があっても（例えば同じ段落の同じ文の誤訳を訳文側で直していた）、LLMにはUnifiedDiffで返せとしているしその変更後訳文はLLMに渡されるようになっている

---

### 3) sync 時にスキップするユニットは存在しない

* `need:*` が付いていても sync は **常に marker 更新まで行う**

---

## UI / コマンドの修正指示

### 全削除対象

以下は **すべて削除**：

* conflict 解決 CodeLens
* 「ソース側採用 / ターゲット側採用 / 手動マージ」UI
* conflict アイコン、警告表示、Hover ヒント
* conflict 件数の集計表示

---

## 設計書の扱い（痕跡としてのみ残す）

* `solve-conflict` という概念は **設計書にのみ最小限で残す**

* 明確に以下を記載すること：

  * **現在の実装では conflict 状態は存在しない**
  * 両方変更されたユニットはすべて revise として処理される
  * 将来、以下のような「危険条件」に限定して復活検討する余地がある：

    * マーカー消失・対応関係の破壊
    * Markdown 構造破壊
    * 差分過大で自動改訂の成功率が低い場合

* 「将来検討」「未実装」「現在は採用しない」を明示し、
  **読んだ人が実装を探しに行かない書き方**にすること

---

## テスト方針（最小）

互換性を考えない前提なので、以下のみでよい：

1. source のみ変更 → `need:revise`
2. source + target 両方変更 → `need:revise`
3. `need:revise` が付いた状態で再 sync → 変更なし（冪等）
4. conflict という概念がコード・UI に存在しないこと。テストからも削除

---

## 完了条件（DoD）

* コードベースから `solve-conflict` / `conflict` という概念が消えている
* sync を何度繰り返しても状態が安定する（隣接ユニットに伝搬しない）
* 両方変更ケースが **すべて revise に流れる**
* 設計書には「将来案」としてのみ solve-conflict が記載されている

---

### 補足（設計意図として共有してよい一文）

> 翻訳ドメインでは「原文と訳文の両方が変更される」ことは通常であり、
> それを conflict と扱うのは過剰防衛である。
> mdait では LLM による diff-aware revise を主戦力とし、
> 人手介入は最終手段とする。

